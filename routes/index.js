var models = require("../models");

module.exports = function(app) {
    app.get("/", function(req, res) {
	    models.RecipeModel.distinct("name", function(err, names) {
	        res.render("index", {"title": "Cellpack", "recNames": names});
	    });
    });


    // REST API
    // POST
    // ACCEPTS NESTED REPRESENTATION FROM CLIENT
    // CONVERTS TO FLAT REPRESENTATION
    // PUSHES FLAT REPRESENTATION TO DB
    app.post("/recipe/:recname/:recversion", function(req, res) {
        // fix function
        console.log(req.body["recipe"]);
        /*
	    var jsonRec = JSON.parse(req.body["recipe"]);
	    var flattened = models.flattenRecipe(jsonRec);

	    while (flattened.length > 0) {
	        for (var r = (flattened.length - 1); r >= 0; r--) {
		        // id generated by client
		        if (flattened[r]["tid"].length < 4) {
		            if (flattened[r]["children"].length < 1) {
			            var baseRec = flattened.splice(r, 1)[0];
			            var newRec = new models.RecipeModel(baseRec);
			            newRec.save(function(err) {
			                if (err) {
				                console.log(err);
			                }
                        });
                        for (var c = 0; c < flattened.length; c++) {
                            var pidIndex = flattened[c]["children"].indexOf(baseRec["tid"]);
                            if (pidIndex > -1)
                                flattened[c]["children"][pidIndex] = newRec._id;
                        }
                    } else {
                        var childrenInDB = true;
                        for (var k = 0; k < flattened[r]["children"]; k++) {
                            if (flattened[r]["children"][k].length < 4)
                                childrenInDB = false;
                        }
                        if (childrenInDB) {
                            var baseRec = flattened.splice(r, 1)[0];
                            var newRec = new RecipeModel(baseRec);
                            newRec.save(function(err) {
                                if (err) {
                                    console.log(err);
                                }
                            });
                            for (var w = 0; w < flattened.length; w++) {
                                var pidIndex = flattened[w]["children"].indexOf(baseRec["tid"]);
                                if (pidIndex > -1)
                                    flattened[w]["children"][pidIndex] = newRec._id;
                            }
                        }
                    }
                }
	        }
	    }
	    res.send("success");
        */
    });

    // REST API
    // GET
    // PULLS FLAT REPRESENTATION FROM DB
    // CONVERTS TO NESTED REPRESENTATION
    // RETURNS NESTED REPRESENTATION TO CLIENT
    app.get("/recipe/:recname/:recversion", function(req, res) {
        console.log(req.body["recipe"]);
        // fix function
        /*
        models.RecipeModel.findOne({ "_id": req.param("recid")}, function(err, rec) {
            var innerQuery = function(recipe, recArray, dist) {
                recArray.push(recipe);
                if (recipe["children"].length > 0) {
                    for (var z = 0; z < recipe["children"].length; z++) {
                        models.RecipeModel.findOne({"_id": recipe["children"][z]}, function(err, r) {
                            innerQuery(r, recArray, false);
                        });
                    }
                }
		    };
            var ra = [];
            innerQuery(rec, ra);
		    res.send(ra);
	    });
        */
    });

    // REST API
    // HELPER FUNCTION
    // RETURNS ARRAY OF RECIPE VERSIONS
    app.get("/recipe/:recname", function(req, res) {
        models.RecipeModel.find({"name": req.param("recname")}, function(err, recipes) {
            var versions = recipes.map(function(r) {return r["version"];});
            res.send(versions);
        });
    });

    require("./create")(app);
}
