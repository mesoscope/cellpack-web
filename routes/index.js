var async = require("async");
var models = require("../models");


module.exports = function(app) {
    app.get("/", function(req, res) {
	    models.RecipeModel.distinct("name", function(err, names) {
	        res.render("index", {"title": "Cellpack", "recNames": names});
	    });
    });


    // REST API
    // POST
    // ACCEPTS NESTED REPRESENTATION FROM CLIENT
    // CONVERTS TO FLAT REPRESENTATION
    // PUSHES FLAT REPRESENTATION TO DB
    app.post("/recipe/:recname/:recversion", function(req, res) {
        // FIX
        // PREVENT NAME CONFLICTS
        // USE ASYNC
	    var jsonRec = JSON.parse(req.body["recipe"]);
	    var flattened = models.flattenRecipe(jsonRec);

	    while (flattened.length > 0) {
	        for (var r = (flattened.length - 1); r >= 0; r--) {
		        // id generated by client
		        if (flattened[r]["tid"].length < 4) {
		            if (flattened[r]["children"].length < 1) {
			            var baseRec = flattened.splice(r, 1)[0];
			            var newRec = new models.RecipeModel(baseRec);
			            newRec.save(function(err) {
			                if (err) {
				                console.log(err);
			                }
                        });
                        for (var c = 0; c < flattened.length; c++) {
                            var pidIndex = flattened[c]["children"].indexOf(baseRec["tid"]);
                            if (pidIndex > -1)
                                flattened[c]["children"][pidIndex] = newRec._id;
                        }
                    } else {
                        var childrenInDB = true;
                        for (var k = 0; k < flattened[r]["children"]; k++) {
                            if (flattened[r]["children"][k].length < 4)
                                childrenInDB = false;
                        }
                        if (childrenInDB) {
                            var baseRec = flattened.splice(r, 1)[0];
                            var newRec = new models.RecipeModel(baseRec);
                            newRec.save(function(err) {
                                if (err) {
                                    console.log(err);
                                }
                            });
                            for (var w = 0; w < flattened.length; w++) {
                                var pidIndex = flattened[w]["children"].indexOf(baseRec["tid"]);
                                if (pidIndex > -1)
                                    flattened[w]["children"][pidIndex] = newRec._id;
                            }
                        }
                    }
                }
	        }
	    }
	    res.send("success");
    });

    // REST API
    // GET
    // PULLS FLAT REPRESENTATION FROM DB
    // CONVERTS TO NESTED REPRESENTATION
    // RETURNS NESTED REPRESENTATION TO CLIENT
    app.get("/recipe/:recname/:recversion", function(req, res) {
        models.RecipeModel.findOne({ "name": req.param("recname"), "version": req.param("recversion")}, function(err, rec) {
            var innerQuery = function(recipe, arr, finishedFunction) {
                arr.push(recipe);
                if (recipe["children"].length > 0) {
                    async.forEachOf(recipe["children"],
                                    function(childId, cidIndex, cb) {
                                        models.RecipeModel.findOne({"_id": childId}, function(err, rec) {
                                            innerQuery(rec, arr, finishedFunction);
                                            cb();
                                        });
                                    },
                                    function(err) {
                                        if (err) {
                                            console.log(err);
                                        }
                                    });
                } else {
                    finishedFunction(arr);
                }
		    };
            var result = [];
            innerQuery(rec, result, function(finishedArray) {
                res.render(models.nestRecipe(finishedArray, req.param("recname"), req.param("recversion")));
            });
	    });
    });

    // REST API
    // HELPER FUNCTION
    // RETURNS ARRAY OF RECIPE VERSIONS
    app.get("/recipe/:recname", function(req, res) {
        models.RecipeModel.find({"name": req.param("recname")}, function(err, recipes) {
            var versions = recipes.map(function(r) {return r["version"];});
            res.send(versions);
        });
    });

    require("./create")(app);
}
